<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/@KeyIndexDefined">True</s:Boolean>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityPlural/@KeyIndexDefined">True</s:Boolean>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityPlural/Order/@EntryValue">6</s:Int64>
	
	
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Shortcut/@EntryValue">mr</s:String>
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Description/@EntryValue">Creates all the objects needed</s:String>
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Text/@EntryValue">namespace $nameSpace$ &#xD;
{&#xD;
    using System;&#xD;
    using Improving.Highway.Data.Scope;&#xD;
    using Improving.Highway.Data.Scope.Concurrency;&#xD;
&#xD;
    public class Entity : IEntity, IRowVersioned&#xD;
    {&#xD;
        public int      Id         { get; set; }&#xD;
        public byte[]   RowVersion { get; set; }&#xD;
        public DateTime Created    { get; set; }&#xD;
        public string   CreatedBy  { get; set; }&#xD;
        public DateTime Modified   { get; set; }&#xD;
        public string   ModifiedBy { get; set; }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using System.ComponentModel.DataAnnotations.Schema;&#xD;
    using System.Data.Entity.ModelConfiguration;&#xD;
&#xD;
    public abstract class BaseMap&lt;T&gt; : EntityTypeConfiguration&lt;T&gt; where T: Entity&#xD;
    {&#xD;
        public const string DateTime2 = "DateTime2";&#xD;
        protected BaseMap()&#xD;
        {&#xD;
            HasKey(x =&gt; x.Id);&#xD;
            Property(x =&gt; x.Id).HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity);&#xD;
            Property(x =&gt; x.CreatedBy).HasMaxLength(200);&#xD;
            Property(x =&gt; x.ModifiedBy).HasMaxLength(200);&#xD;
            Property(x =&gt; x.Created).HasColumnType(DateTime2);&#xD;
            Property(x =&gt; x.Modified).HasColumnType(DateTime2);&#xD;
            Property(x =&gt; x.RowVersion).HasColumnType("ROWVERSION");&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Improving.Highway.Data.Scope;&#xD;
    using Improving.Highway.Data.Scope.Concurrency;&#xD;
    using Improving.MediatR;&#xD;
&#xD;
    public class $Entity$ : Entity, IKeyProperties&lt;int&gt;, IEntity, IRowVersioned&#xD;
    {&#xD;
        public string Text { get; set; }&#xD;
        public string Name { get; set; }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
&#xD;
    public class $Entity$Map : BaseMap&lt;$Entity$&gt;&#xD;
    {&#xD;
        public $Entity$Map()&#xD;
        {&#xD;
            ToTable(nameof($Entity$));&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Improving.MediatR;&#xD;
&#xD;
    public class $Entity$Data : Resource&lt;int&gt;&#xD;
    {&#xD;
        public string Text { get; set; }&#xD;
        public string Name { get; set; }&#xD;
    }&#xD;
}&#xD;
	&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    public class $Entity$Result&#xD;
    {&#xD;
        public $Entity$Data[] $EntityPlural$ { get; set; }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using System;&#xD;
    using System.Linq;&#xD;
    using System.Threading.Tasks;&#xD;
    using Improving.Highway.Data.Scope.Repository;&#xD;
    using Improving.MediatR;&#xD;
    using Improving.MediatR.Pipeline;&#xD;
    using MediatR;&#xD;
&#xD;
	[RelativeOrder(Stage.Validation - 1)]&#xD;
    public class $Entity$AggregateHandler :&#xD;
        IAsyncRequestHandler&lt;Create$Entity$, $Entity$Data&gt;,&#xD;
        IAsyncRequestHandler&lt;Get$EntityPlural$, $Entity$Result&gt;,&#xD;
        IAsyncRequestHandler&lt;Update$Entity$, $Entity$Data&gt;,&#xD;
        IRequestMiddleware&lt;Update$Entity$, $Entity$Data&gt;,&#xD;
        IAsyncRequestHandler&lt;Remove$Entity$, $Entity$Data&gt;,&#xD;
        IRequestMiddleware&lt;Remove$Entity$, $Entity$Data&gt;&#xD;
    {&#xD;
        private readonly IRepository&lt;$DataDomain$&gt; _repository;&#xD;
        private readonly DateTime _now;&#xD;
&#xD;
		public $Entity$ $Entity$ { get; set; }&#xD;
&#xD;
        public $Entity$AggregateHandler(IRepository&lt;$DataDomain$&gt; repository)&#xD;
        {&#xD;
            _repository = repository;&#xD;
            _now        = DateTime.Now;&#xD;
        }&#xD;
&#xD;
		#region Create $Entity$&#xD;
&#xD;
        public async Task&lt;$Entity$Data&gt; Handle(Create$Entity$ message)&#xD;
        {&#xD;
			using(var scope = _repository.Scopes.Create())&#xD;
			{&#xD;
				var $entityLowercase$ = Map(new $Entity$(), message.Resource);&#xD;
				$entityLowercase$.Created = _now;&#xD;
&#xD;
				_repository.Context.Add($entityLowercase$);&#xD;
&#xD;
				var data = new $Entity$Data();&#xD;
&#xD;
				await scope.SaveChangesAsync((dbScope, count) =&gt;&#xD;
				{&#xD;
					data.Id = $entityLowercase$.Id;&#xD;
					data.RowVersion = $entityLowercase$.RowVersion;&#xD;
				});&#xD;
&#xD;
				return data;&#xD;
			}&#xD;
        }&#xD;
&#xD;
		#endregion&#xD;
&#xD;
		#region Get $Entity$&#xD;
&#xD;
        public async Task&lt;$Entity$Result&gt; Handle(Get$EntityPlural$ message)&#xD;
        {&#xD;
            using(_repository.Scopes.CreateReadOnly())&#xD;
			{&#xD;
				var $entityPluralLowercase$ = (await _repository.FindAsync(new Get$EntityPlural$ById(message.Ids){&#xD;
					KeyProperties = message.KeyProperties&#xD;
				})).Select(x =&gt; Map(new $Entity$Data(), x)).ToArray();&#xD;
&#xD;
				return new $Entity$Result&#xD;
				{&#xD;
					$EntityPlural$ = $entityPluralLowercase$&#xD;
				};&#xD;
			}&#xD;
        }&#xD;
&#xD;
		#endregion&#xD;
&#xD;
		#region Update $Entity$&#xD;
&#xD;
        public async Task&lt;$Entity$Data&gt; Apply(Update$Entity$ request, Func&lt;Update$Entity$, Task&lt;$Entity$Data&gt;&gt; next)&#xD;
        {&#xD;
            using (var scope = _repository.Scopes.Create())&#xD;
            {&#xD;
                var data = request.Resource;&#xD;
                if ($Entity$ == null &amp;&amp; data != null)&#xD;
                {&#xD;
                    $Entity$ = await _repository.FetchByIdAsync&lt;$Entity$&gt;(data.Id);&#xD;
                    Env.Use($Entity$);&#xD;
                }&#xD;
&#xD;
                var result = await next(request);&#xD;
                await scope.SaveChangesAsync();&#xD;
&#xD;
                result.RowVersion = $Entity$?.RowVersion;&#xD;
                return result;&#xD;
            }&#xD;
        }&#xD;
&#xD;
        public Task&lt;$Entity$Data&gt; Handle(Update$Entity$ request)&#xD;
        {&#xD;
            Map($Entity$, request.Resource);&#xD;
&#xD;
            return Task.FromResult(new $Entity$Data&#xD;
            {&#xD;
                Id = request.Resource.Id&#xD;
            });&#xD;
        }&#xD;
&#xD;
		#endregion&#xD;
&#xD;
		#region Remove $Entity$&#xD;
&#xD;
        public async Task&lt;$Entity$Data&gt; Apply(&#xD;
            Remove$Entity$ request, Func&lt;Remove$Entity$, Task&lt;$Entity$Data&gt;&gt; next)&#xD;
        {&#xD;
            using (var scope = _repository.Scopes.Create())&#xD;
            {&#xD;
                var resource = request.Resource;&#xD;
                if ($Entity$ == null &amp;&amp; resource != null)&#xD;
                {&#xD;
                    $Entity$ = await _repository.FetchByIdAsync&lt;$Entity$&gt;(resource.Id);&#xD;
                    Env.Use($Entity$);&#xD;
                }&#xD;
&#xD;
                var result = await next(request);&#xD;
                await scope.SaveChangesAsync();&#xD;
                return result;&#xD;
            }&#xD;
        }&#xD;
&#xD;
        public Task&lt;$Entity$Data&gt; Handle(Remove$Entity$ request)&#xD;
        {&#xD;
            _repository.Context.Remove($Entity$);&#xD;
&#xD;
            return Task.FromResult(new $Entity$Data&#xD;
            {&#xD;
                Id         = $Entity$.Id,&#xD;
                RowVersion = $Entity$.RowVersion&#xD;
            });&#xD;
        }&#xD;
&#xD;
		#endregion&#xD;
&#xD;
&#xD;
		#region Mapping&#xD;
&#xD;
        public $Entity$ Map($Entity$ $entityLowercase$, $Entity$Data data)&#xD;
        {&#xD;
            if (data.Name != null)&#xD;
                $entityLowercase$.Name = data.Name;&#xD;
				&#xD;
            if (data.Text != null)&#xD;
                $entityLowercase$.Text = data.Text;&#xD;
&#xD;
            if (data.CreatedBy != null)&#xD;
                $entityLowercase$.CreatedBy = data.CreatedBy;&#xD;
&#xD;
            if (data.ModifiedBy != null)&#xD;
                $entityLowercase$.ModifiedBy = data.ModifiedBy;&#xD;
&#xD;
            $entityLowercase$.Modified = _now;&#xD;
&#xD;
            return $entityLowercase$;&#xD;
        }&#xD;
&#xD;
        public $Entity$Data Map($Entity$Data data, $Entity$ $entityLowercase$)&#xD;
        {&#xD;
			data.Id         = $entityLowercase$.Id;&#xD;
			data.Name       = $entityLowercase$.Name;&#xD;
			data.Text       = $entityLowercase$.Text;&#xD;
			data.RowVersion = $entityLowercase$.RowVersion;&#xD;
			data.CreatedBy  = $entityLowercase$.CreatedBy;&#xD;
			data.Created    = $entityLowercase$.Created;&#xD;
			data.ModifiedBy = $entityLowercase$.ModifiedBy;&#xD;
			data.Modified   = $entityLowercase$.Modified;&#xD;
&#xD;
            return data;&#xD;
        }&#xD;
&#xD;
		#endregion&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Improving.MediatR;&#xD;
&#xD;
    public class Create$Entity$ : ResourceAction&lt;$Entity$Data, int&gt;&#xD;
    {&#xD;
        public Create$Entity$()&#xD;
        {&#xD;
        }&#xD;
&#xD;
        public Create$Entity$($Entity$Data $entityLowercase$)&#xD;
            : base ($entityLowercase$)&#xD;
        {&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using System.Threading.Tasks;&#xD;
    using FizzWare.NBuilder;&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
    using Rhino.Mocks;&#xD;
&#xD;
    [TestClass]&#xD;
    public class Create$Entity$Tests : TestScenario&#xD;
    {&#xD;
        [TestMethod]&#xD;
        public async Task ShouldCreate$Entity$()&#xD;
        {&#xD;
            var $entityLowercase$ = Builder&lt;$Entity$Data&gt;.CreateNew()&#xD;
                  .With(pg =&gt; pg.Id = 0).And(pg =&gt; pg.RowVersion = null)&#xD;
                  .Build();&#xD;
&#xD;
            _context.Expect(pg =&gt; pg.Add(Arg&lt;$Entity$&gt;.Is.Anything))&#xD;
                  .WhenCalled(inv =&gt;&#xD;
                  {&#xD;
                      var entity = ($Entity$)inv.Arguments[0];&#xD;
                      entity.Id         = 1;&#xD;
                      entity.RowVersion = new byte[] { 0x01 };&#xD;
                      Assert.AreEqual($entityLowercase$.Text, entity.Text);&#xD;
                      inv.ReturnValue = entity;&#xD;
                  }).Return(null);&#xD;
&#xD;
            _context.Expect(pg =&gt; pg.CommitAsync())&#xD;
                .Return(Task.FromResult(1));&#xD;
&#xD;
            var result = await _mediator.SendAsync(new Create$Entity$($entityLowercase$));&#xD;
            Assert.AreEqual(1, result.Id);&#xD;
            CollectionAssert.AreEqual(new byte[] { 0x01 }, result.RowVersion);&#xD;
&#xD;
            _context.VerifyAllExpectations();&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using FluentValidation;&#xD;
&#xD;
    public class Create$Entity$Integrity : AbstractValidator&lt;Create$Entity$&gt;&#xD;
    {&#xD;
        public Create$Entity$Integrity()&#xD;
        {&#xD;
            RuleFor(x =&gt; x.Resource)&#xD;
                .NotNull()&#xD;
                .SetValidator(new $Entity$DataIntegrity());&#xD;
        }&#xD;
&#xD;
        private class $Entity$DataIntegrity : AbstractValidator&lt;$Entity$Data&gt;&#xD;
        {&#xD;
            public $Entity$DataIntegrity()&#xD;
            {&#xD;
                RuleFor(x =&gt; x.Text)&#xD;
                    .NotEmpty();&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
&#xD;
    [TestClass]&#xD;
    public class Create$Entity$IntegrityTests&#xD;
    {&#xD;
        private Create$Entity$ create$Entity$;&#xD;
        private Create$Entity$Integrity validator;&#xD;
&#xD;
        [TestInitialize]&#xD;
        public void TestInitialize()&#xD;
        {&#xD;
            create$Entity$ =  new Create$Entity$&#xD;
            {&#xD;
                 Resource = new $Entity$Data&#xD;
                 {&#xD;
                    Text = "my text"&#xD;
                 }&#xD;
            };&#xD;
&#xD;
            validator = new Create$Entity$Integrity();&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public void IsValid()&#xD;
        {&#xD;
            var result = validator.Validate(create$Entity$);&#xD;
            Assert.IsTrue(result.IsValid);&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public void MustHaveText()&#xD;
        {&#xD;
            create$Entity$.Resource.Text = string.Empty;&#xD;
            var result = validator.Validate(create$Entity$);&#xD;
            Assert.IsFalse(result.IsValid);&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Improving.MediatR;&#xD;
&#xD;
    public class Get$EntityPlural$ : Request.WithResponse&lt;$Entity$Result&gt;&#xD;
    {&#xD;
        public Get$EntityPlural$()&#xD;
        {&#xD;
            Ids = new int[0];&#xD;
        }&#xD;
&#xD;
        public Get$EntityPlural$(params int[] ids)&#xD;
        {&#xD;
            Ids = ids;&#xD;
        }&#xD;
&#xD;
        public int[] Ids { get; set;}&#xD;
&#xD;
		public bool KeyProperties { get; set; }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
    using System.Linq;&#xD;
    using System.Threading.Tasks;&#xD;
    using Rhino.Mocks;&#xD;
    using Temp.Foos;&#xD;
&#xD;
    [TestClass]&#xD;
    public class Get$entityPlural$Tests : TestScenario&#xD;
    {&#xD;
        [TestMethod]&#xD;
        public async Task ShouldGet$EntityPlural$()&#xD;
        {&#xD;
            SetupChoices();&#xD;
&#xD;
            var result = await _mediator.SendAsync(new Get$EntityPlural$());&#xD;
            Assert.AreEqual(3, result.$EntityPlural$.Length);&#xD;
&#xD;
            _context.VerifyAllExpectations();&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public async Task ShouldGetOnlyKeyProperties()&#xD;
        {&#xD;
            _context.Stub(p =&gt; p.AsQueryable&lt;$Entity$&gt;())&#xD;
                .Return(TestChoice&lt;$Entity$&gt;(3).TestAsync());&#xD;
&#xD;
            var result = await _mediator.SendAsync(new Get$EntityPlural$ { KeyProperties = true });&#xD;
&#xD;
            Assert.IsTrue(result.$EntityPlural$.All(x =&gt; x.Name != null));&#xD;
            Assert.IsTrue(result.$EntityPlural$.All(x =&gt; x.CreatedBy == null));&#xD;
&#xD;
            _context.VerifyAllExpectations();&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using System.Linq;&#xD;
    using System.Data.Entity;&#xD;
    using Highway.Data;&#xD;
	&#xD;
    public class Get$EntityPlural$ById : Query&lt;$Entity$&gt;&#xD;
    {&#xD;
		public bool KeyProperties { get; set; }&#xD;
&#xD;
        public Get$EntityPlural$ById(int[] ids)&#xD;
        {&#xD;
            ContextQuery = c =&gt;&#xD;
            {&#xD;
                var query = Context.AsQueryable&lt;$Entity$&gt;().AsNoTracking();&#xD;
&#xD;
                if (ids?.Length == 1)&#xD;
                {&#xD;
                    var id = ids[0];&#xD;
                    query = query.Where(x =&gt; x.Id == id);&#xD;
                }&#xD;
                else if (ids?.Length &gt; 1)&#xD;
                {&#xD;
                    query = query.Where(x =&gt; ids.Contains(x.Id));&#xD;
                }&#xD;
				&#xD;
			    if (KeyProperties)&#xD;
			    {&#xD;
				    return query.Select(x =&gt; new $Entity${Id = x.Id, Name = x.Name});&#xD;
			    }&#xD;
&#xD;
                return query;&#xD;
            };&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using Improving.MediatR;&#xD;
&#xD;
    public class Update$Entity$ : UpdateResource&lt;$Entity$Data, int&gt;&#xD;
    {&#xD;
        public Update$Entity$()&#xD;
        {&#xD;
        }&#xD;
&#xD;
        public Update$Entity$($Entity$Data $entityLowercase$)&#xD;
            : base($entityLowercase$)&#xD;
        {          &#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
    using System.Linq;&#xD;
    using System.Threading.Tasks;&#xD;
    using FizzWare.NBuilder;&#xD;
    using Rhino.Mocks;&#xD;
&#xD;
    [TestClass]&#xD;
    public class Update$Entity$Tests : TestScenario&#xD;
    {&#xD;
        [TestMethod]&#xD;
        public async Task ShouldUpdate$Entity$()&#xD;
        {&#xD;
            var $entityLowercase$= new $Entity$()&#xD;
            {&#xD;
                Id         = 1,&#xD;
                Name       = "ABC",&#xD;
                RowVersion = new byte[] { 0x01 }&#xD;
            };&#xD;
&#xD;
            var $entityLowercase$Data = Builder&lt;$Entity$Data&gt;.CreateNew()&#xD;
                .With(c =&gt; c.Id = 1).And(c =&gt; c.RowVersion = new byte[] { 0x01 })&#xD;
                .Build();&#xD;
&#xD;
            _context.Expect(c =&gt; c.AsQueryable&lt;$Entity$&gt;())&#xD;
                .Return(new[] { $entityLowercase$ }.AsQueryable().TestAsync());&#xD;
&#xD;
            _context.Expect(c =&gt; c.CommitAsync())&#xD;
                .WhenCalled(inv =&gt; $entityLowercase$.RowVersion = new byte[] { 0x02 })&#xD;
                .Return(Task.FromResult(1));&#xD;
&#xD;
            var result = await _mediator.SendAsync(new Update$Entity$($entityLowercase$Data));&#xD;
            Assert.AreEqual(1, result.Id);&#xD;
            CollectionAssert.AreEqual(new byte[] { 0x02 }, result.RowVersion);&#xD;
&#xD;
            Assert.AreEqual($entityLowercase$Data.Name, $entityLowercase$.Name);&#xD;
&#xD;
            _context.VerifyAllExpectations();&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using FluentValidation;&#xD;
&#xD;
    public class Update$Entity$Integrity : AbstractValidator&lt;Update$Entity$&gt;&#xD;
    {&#xD;
        public Update$Entity$Integrity()&#xD;
        {&#xD;
            RuleFor(x =&gt; x.Resource)&#xD;
                .NotNull()&#xD;
                .SetValidator(new $Entity$DataIntegrity());&#xD;
        }&#xD;
&#xD;
        private class $Entity$DataIntegrity : AbstractValidator&lt;$Entity$Data&gt;&#xD;
        {&#xD;
            public $Entity$DataIntegrity()&#xD;
            {&#xD;
                RuleFor(x =&gt; x.Text)&#xD;
                    .NotEmpty();&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
&#xD;
    [TestClass]&#xD;
    public class Update$Entity$IntegrityTests&#xD;
    {&#xD;
        private Update$Entity$ update$Entity$;&#xD;
        private Update$Entity$Integrity validator;&#xD;
&#xD;
        [TestInitialize]&#xD;
        public void TestInitialize()&#xD;
        {&#xD;
            update$Entity$ =  new Update$Entity$&#xD;
            {&#xD;
                 Resource = new $Entity$Data&#xD;
                 {&#xD;
                    Text = "my text"&#xD;
                 }&#xD;
            };&#xD;
&#xD;
            validator = new Update$Entity$Integrity();&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public void IsValid()&#xD;
        {&#xD;
            var result = validator.Validate(update$Entity$);&#xD;
            Assert.IsTrue(result.IsValid);&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public void MustHaveText()&#xD;
        {&#xD;
            update$Entity$.Resource.Text = string.Empty;&#xD;
            var result = validator.Validate(update$Entity$);&#xD;
            Assert.IsFalse(result.IsValid);&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$ &#xD;
{&#xD;
    using Improving.MediatR;&#xD;
&#xD;
    public class Remove$Entity$ : UpdateResource&lt;$Entity$Data, int&gt;&#xD;
    {&#xD;
        public Remove$Entity$()&#xD;
        {&#xD;
        }&#xD;
&#xD;
        public Remove$Entity$($Entity$Data $entityLowercase$)&#xD;
            : base($entityLowercase$)&#xD;
        {&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using System.Linq;&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
    using System.Threading.Tasks;&#xD;
    using FizzWare.NBuilder;&#xD;
    using Rhino.Mocks;&#xD;
&#xD;
&#xD;
    [TestClass]&#xD;
    public class Remove$Entity$Tests : TestScenario&#xD;
    {&#xD;
        [TestMethod]&#xD;
        public async Task ShouldRemove$Entity$()&#xD;
        {&#xD;
            var entity = new $Entity$&#xD;
            {&#xD;
                Id         = 1,&#xD;
                Text       = "ABC",&#xD;
                RowVersion = new byte[] { 0x01 }&#xD;
            };&#xD;
&#xD;
            var $entityLowercase$Data = Builder&lt;$Entity$Data&gt;.CreateNew()&#xD;
                .With(pg =&gt; pg.Id = 1).And(c =&gt; c.RowVersion = new byte[] { 0x01 })&#xD;
                .Build();&#xD;
&#xD;
            _context.Expect(pg =&gt; pg.AsQueryable&lt;$Entity$&gt;())&#xD;
                .Return(new[] { entity }.AsQueryable().TestAsync());&#xD;
&#xD;
            _context.Expect(c =&gt; c.Remove(entity))&#xD;
                .Return(entity);&#xD;
&#xD;
            _context.Expect(c =&gt; c.CommitAsync())&#xD;
                .Return(Task.FromResult(1));&#xD;
&#xD;
            var result = await _mediator.SendAsync(new Remove$Entity$($entityLowercase$Data));&#xD;
            Assert.AreEqual(1, result.Id);&#xD;
            CollectionAssert.AreEqual(new byte[] { 0x01 }, result.RowVersion);&#xD;
&#xD;
            _context.VerifyAllExpectations();&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using Improving.MediatR;&#xD;
    using Improving.Highway.Data.Scope.Concurrency;&#xD;
&#xD;
    [RelativeOrder(5), StopOnFailure]&#xD;
    public class $Entity$Concurency : CheckConcurrency&lt;$Entity$, $Entity$Data&gt;&#xD;
    {&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace $nameSpace$&#xD;
{&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
    using System.Data.Entity.Core;&#xD;
    using System.Linq;&#xD;
    using Castle.MicroKernel.Registration;&#xD;
    using Castle.Windsor;&#xD;
    using FizzWare.NBuilder;&#xD;
    using Improving.MediatR;&#xD;
    using Rhino.Mocks;&#xD;
&#xD;
    [TestClass]&#xD;
    public class $Entity$ConcurrencyTests : TestScenario&#xD;
    {&#xD;
        private $Entity$ _$entityLowercase$;&#xD;
&#xD;
        protected override void BeforeContainer(IWindsorContainer container)&#xD;
        {&#xD;
            _$entityLowercase$ = Builder&lt;$Entity$&gt;.CreateNew()&#xD;
                 .With(b =&gt; b.Id = 1)&#xD;
                 .And(b =&gt; b.RowVersion = new byte[] { 0x02 })&#xD;
                 .Build();&#xD;
            container.Register(Component.For&lt;$Entity$&gt;().Instance(_$entityLowercase$));&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public void DetectsConcurrencyViolationOnUpdate()&#xD;
        {&#xD;
            var $entityLowercase$ = Builder&lt;$Entity$Data&gt;.CreateNew()&#xD;
               .With(c =&gt; c.Id = 1).And(c =&gt; c.RowVersion = new byte[] { 0x01 })&#xD;
               .Build();&#xD;
&#xD;
            _context.Expect(c =&gt; c.AsQueryable&lt;$Entity$&gt;())&#xD;
                .Return(new[] { _$entityLowercase$ }.AsQueryable().TestAsync());&#xD;
&#xD;
            var request = new Update$Entity$($entityLowercase$);&#xD;
&#xD;
            try&#xD;
            {&#xD;
                AssertNoValidationErrors&lt;$Entity$Concurency, UpdateResource&lt;$Entity$Data, int&gt;&gt;(request);&#xD;
                Assert.Fail("Should have thrown OptimisticConcurrencyException");&#xD;
            }&#xD;
            catch (OptimisticConcurrencyException ex)&#xD;
            {&#xD;
                Assert.AreEqual(ex.Message,&#xD;
                    $"Concurrency exception detected for {typeof($Entity$).FullName} with id 1.");&#xD;
            }&#xD;
        }&#xD;
&#xD;
        [TestMethod]&#xD;
        public void DetectsConcurrencyViolationOnRemove()&#xD;
        {&#xD;
            var $entityLowercase$ = Builder&lt;$Entity$Data&gt;.CreateNew()&#xD;
               .With(c =&gt; c.Id = 1).And(c =&gt; c.RowVersion = new byte[] { 0x01 })&#xD;
               .Build();&#xD;
&#xD;
            _context.Expect(c =&gt; c.AsQueryable&lt;$Entity$&gt;())&#xD;
                .Return(new[] { _$entityLowercase$ }.AsQueryable().TestAsync());&#xD;
&#xD;
            var request = new Remove$Entity$($entityLowercase$);&#xD;
&#xD;
            try&#xD;
            {&#xD;
                AssertNoValidationErrors&lt;$Entity$Concurency, UpdateResource&lt;$Entity$Data, int&gt;&gt;(request);&#xD;
                Assert.Fail("Should have thrown OptimisticConcurrencyException");&#xD;
            }&#xD;
            catch (OptimisticConcurrencyException ex)&#xD;
            {&#xD;
                Assert.AreEqual(ex.Message,&#xD;
                    $"Concurrency exception detected for {typeof($Entity$).FullName} with id 1.");&#xD;
            }&#xD;
        }&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace Temp.Foos&#xD;
{&#xD;
    using System.Linq;&#xD;
    using System.Threading.Tasks;&#xD;
    using Castle.DynamicProxy;&#xD;
    using Castle.MicroKernel.Lifestyle;&#xD;
    using Castle.MicroKernel.Registration;&#xD;
    using Castle.Windsor;&#xD;
    using Castle.Windsor.Installer;&#xD;
    using FizzWare.NBuilder;&#xD;
    using global::MediatR;&#xD;
    using Highway.Data;&#xD;
    using Improving.Highway.Data.Scope.Repository;&#xD;
    using Improving.MediatR;&#xD;
    using Improving.MediatR.Cache;&#xD;
    using Microsoft.VisualStudio.TestTools.UnitTesting;&#xD;
    using Rhino.Mocks;&#xD;
    using FluentValidation;&#xD;
&#xD;
    public class TestScenario&#xD;
    {&#xD;
        protected RandomGenerator _random;&#xD;
        protected IWindsorContainer _container;&#xD;
        protected IDomainContext&lt;IDomain&gt; _context;&#xD;
        protected IMediator _mediator;&#xD;
&#xD;
        [TestInitialize]&#xD;
        public virtual void TestInitialize()&#xD;
        {&#xD;
            _random = new RandomGenerator();&#xD;
            _context = MockRepository.GenerateMock&lt;IDomainContext&lt;IDomain&gt;&gt;();&#xD;
&#xD;
            _container = new WindsorContainer();&#xD;
            BeforeContainer(_container);&#xD;
&#xD;
            _container.Register(&#xD;
                Component.For&lt;IDomainContext&lt;$DataDomain$&gt;&gt;().Instance(_context))&#xD;
                .Install(&#xD;
                    new MediatRInstaller(&#xD;
                        Classes.FromThisAssembly(),&#xD;
                        Classes.FromAssemblyContaining&lt;IDomainContext&lt;$DataDomain$&gt;&gt;()),&#xD;
                    new RepositoryInstaller(&#xD;
                        Classes.FromAssemblyContaining&lt;IDomainContext&lt;$DataDomain$&gt;&gt;()),&#xD;
                    FromAssembly.Containing&lt;IDomainContext&lt;$DataDomain$&gt;&gt;()&#xD;
                );&#xD;
&#xD;
            AfterContainer(_container);&#xD;
&#xD;
            _mediator = _container.Resolve&lt;IMediator&gt;();&#xD;
        }&#xD;
&#xD;
        protected virtual void BeforeContainer(IWindsorContainer container)&#xD;
        {&#xD;
        }&#xD;
&#xD;
        protected virtual void AfterContainer(IWindsorContainer container)&#xD;
        {&#xD;
        }&#xD;
&#xD;
        [TestCleanup]&#xD;
        public virtual void TestCleanup()&#xD;
        {&#xD;
            _container?.Dispose();&#xD;
        }&#xD;
&#xD;
        protected virtual void SetupChoices()&#xD;
        {&#xD;
            InvalidateCache(new Get$EntityPlural$());&#xD;
&#xD;
            _context.Stub(p =&gt; p.AsQueryable&lt;$Entity$&gt;())&#xD;
                .Return(TestChoice&lt;$Entity$&gt;(3).TestAsync());&#xD;
&#xD;
        }&#xD;
&#xD;
        protected void InvalidateCache&lt;TResponse&gt;(Request.WithResponse&lt;TResponse&gt; request)&#xD;
                where TResponse : class&#xD;
        {&#xD;
            _mediator.SendAsync(request.InvalidateCache());&#xD;
        }&#xD;
&#xD;
        protected static IQueryable&lt;T&gt; TestChoice&lt;T&gt;(int howMany)&#xD;
        {&#xD;
            return Builder&lt;T&gt;.CreateListOfSize(howMany).Build().AsQueryable();&#xD;
        }&#xD;
&#xD;
        public TestScenario ExpectContextToSaveAsync()&#xD;
        {&#xD;
            _context&#xD;
                .Stub(x =&gt; x.CommitAsync())&#xD;
                .Return(Task.FromResult(0));&#xD;
            return this;&#xD;
        }&#xD;
&#xD;
        protected void AssertValidationErrors&lt;T, R&gt;(R request, params string[] errors) where T : IValidator&lt;R&gt;&#xD;
        {&#xD;
            var validator = GetValidator&lt;T, R&gt;();&#xD;
            var results = validator.Validate(request);&#xD;
            var actual = results.Errors.Select(e =&gt; e.ErrorMessage).ToArray();&#xD;
            foreach (var error in errors)&#xD;
                CollectionAssert.Contains(actual, error);&#xD;
        }&#xD;
&#xD;
		protected void AssertNoValidationErrors&lt;T, R&gt;(R request) where T : IValidator&lt;R&gt;&#xD;
        {&#xD;
            var validator = GetValidator&lt;T, R&gt;();&#xD;
            var results = validator.Validate(request);&#xD;
            if (results.Errors.Count &gt; 0)&#xD;
                Assert.Fail($"Expected no validation errors, but found {results.Errors.Count}");&#xD;
        }&#xD;
&#xD;
        protected IValidator GetValidator&lt;T, R&gt;() where T : IValidator&lt;R&gt;&#xD;
        {&#xD;
            var mediatR = _container.GetChildContainer("Improving.MediatR");&#xD;
            using (mediatR.BeginScope())&#xD;
            {&#xD;
                return mediatR.ResolveAll&lt;IValidator&lt;R&gt;&gt;()&#xD;
                    .First(v =&gt; ProxyUtil.GetUnproxiedType(v).IsAssignableFrom(typeof(T)));&#xD;
            }&#xD;
        }&#xD;
&#xD;
    }&#xD;
}&#xD;
&#xD;
namespace Temp.Foos&#xD;
{&#xD;
    using System;&#xD;
    using System.Collections.Generic;&#xD;
    using System.Data.Entity.Infrastructure;&#xD;
    using System.Linq;&#xD;
    using System.Linq.Expressions;&#xD;
    using System.Threading;&#xD;
    using System.Threading.Tasks;&#xD;
    using Rhino.Mocks;&#xD;
    using Rhino.Mocks.Interfaces;&#xD;
&#xD;
    public static class AsyncQueryTesting&#xD;
    {&#xD;
        public interface IAsyncQueryable&lt;out T&gt; : IQueryable&lt;T&gt;, IDbAsyncEnumerable&lt;T&gt; { }&#xD;
&#xD;
        public static IQueryable&lt;T&gt; TestAsync&lt;T&gt;(this IQueryable&lt;T&gt; queryable)&#xD;
        {&#xD;
            var asyncProvider = new TestDbAsyncQueryProvider&lt;T&gt;(queryable.Provider);&#xD;
            var mockQueryable = MockRepository.GenerateStub&lt;IAsyncQueryable&lt;T&gt;&gt;();&#xD;
            mockQueryable.Stub(q =&gt; q.GetAsyncEnumerator())&#xD;
                .Return(() =&gt; new TestDbAsyncEnumerator&lt;T&gt;(queryable.GetEnumerator()));&#xD;
            mockQueryable.Stub(q =&gt; q.Provider).Return(asyncProvider);&#xD;
            mockQueryable.Stub(q =&gt; q.ElementType).Return(queryable.ElementType);&#xD;
            mockQueryable.Stub(q =&gt; q.Expression).Return(queryable.Expression);&#xD;
            mockQueryable.Stub(q =&gt; q.GetEnumerator()).Return(queryable.GetEnumerator);&#xD;
            return mockQueryable;&#xD;
        }&#xD;
&#xD;
        public static IMethodOptions&lt;T&gt; Return&lt;T&gt;(this IMethodOptions&lt;T&gt; opts, Func&lt;T&gt; factory)&#xD;
        {&#xD;
            opts.Return(default(T));    // required for Rhino.Mocks on non-void methods&#xD;
            opts.WhenCalled(mi =&gt; mi.ReturnValue = factory());&#xD;
            return opts;&#xD;
        }&#xD;
    }&#xD;
&#xD;
    #region TestDbAsyncQueryProvider&#xD;
&#xD;
    internal class TestDbAsyncQueryProvider&lt;TEntity&gt; : IDbAsyncQueryProvider&#xD;
    {&#xD;
        private readonly IQueryProvider _inner;&#xD;
&#xD;
        internal TestDbAsyncQueryProvider(IQueryProvider inner)&#xD;
        {&#xD;
            _inner = inner;&#xD;
        }&#xD;
&#xD;
        public IQueryable CreateQuery(Expression expression)&#xD;
        {&#xD;
            return new TestDbAsyncEnumerable&lt;TEntity&gt;(expression);&#xD;
        }&#xD;
&#xD;
        public IQueryable&lt;TElement&gt; CreateQuery&lt;TElement&gt;(Expression expression)&#xD;
        {&#xD;
            return new TestDbAsyncEnumerable&lt;TElement&gt;(expression);&#xD;
        }&#xD;
&#xD;
        public object Execute(Expression expression)&#xD;
        {&#xD;
            return _inner.Execute(expression);&#xD;
        }&#xD;
&#xD;
        public TResult Execute&lt;TResult&gt;(Expression expression)&#xD;
        {&#xD;
            return _inner.Execute&lt;TResult&gt;(expression);&#xD;
        }&#xD;
&#xD;
        public Task&lt;object&gt; ExecuteAsync(Expression expression, CancellationToken cancellationToken)&#xD;
        {&#xD;
            return Task.FromResult(Execute(expression));&#xD;
        }&#xD;
&#xD;
        public Task&lt;TResult&gt; ExecuteAsync&lt;TResult&gt;(Expression expression, CancellationToken cancellationToken)&#xD;
        {&#xD;
            return Task.FromResult(Execute&lt;TResult&gt;(expression));&#xD;
        }&#xD;
    }&#xD;
&#xD;
    #endregion&#xD;
&#xD;
    #region TestDbAsyncEnumerable&#xD;
&#xD;
    internal class TestDbAsyncEnumerable&lt;T&gt;&#xD;
        : EnumerableQuery&lt;T&gt;, IDbAsyncEnumerable&lt;T&gt;, IQueryable&lt;T&gt;&#xD;
    {&#xD;
        public TestDbAsyncEnumerable(IEnumerable&lt;T&gt; enumerable)&#xD;
            : base(enumerable)&#xD;
        {&#xD;
        }&#xD;
&#xD;
        public TestDbAsyncEnumerable(Expression expression)&#xD;
            : base(expression)&#xD;
        {&#xD;
        }&#xD;
&#xD;
        IQueryProvider IQueryable.Provider =&gt; new TestDbAsyncQueryProvider&lt;T&gt;(this);&#xD;
&#xD;
        IDbAsyncEnumerator IDbAsyncEnumerable.GetAsyncEnumerator()&#xD;
        {&#xD;
            return GetAsyncEnumerator();&#xD;
        }&#xD;
&#xD;
        public IDbAsyncEnumerator&lt;T&gt; GetAsyncEnumerator()&#xD;
        {&#xD;
            return new TestDbAsyncEnumerator&lt;T&gt;(this.AsEnumerable().GetEnumerator());&#xD;
        }&#xD;
    }&#xD;
&#xD;
    #endregion&#xD;
&#xD;
    #region TestDbAsyncEnumerator&#xD;
&#xD;
    internal class TestDbAsyncEnumerator&lt;T&gt; : IDbAsyncEnumerator&lt;T&gt;&#xD;
    {&#xD;
        private readonly IEnumerator&lt;T&gt; _inner;&#xD;
&#xD;
        public TestDbAsyncEnumerator(IEnumerator&lt;T&gt; inner)&#xD;
        {&#xD;
            _inner = inner;&#xD;
        }&#xD;
&#xD;
        public T Current =&gt; _inner.Current;&#xD;
&#xD;
        object IDbAsyncEnumerator.Current =&gt; Current;&#xD;
&#xD;
        public Task&lt;bool&gt; MoveNextAsync(CancellationToken cancellationToken)&#xD;
        {&#xD;
            return Task.FromResult(_inner.MoveNext());&#xD;
        }&#xD;
&#xD;
        public void Dispose()&#xD;
        {&#xD;
            _inner.Dispose();&#xD;
        }&#xD;
    }&#xD;
&#xD;
	#endregion&#xD;
}&#xD;
</s:String>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/ShortenQualifiedReferences/@EntryValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Applicability/=Live/@EntryIndexedValue">True</s:Boolean>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Scope/=C3001E7C0DA78E4487072B7E050D86C5/@KeyIndexDefined">True</s:Boolean>
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Scope/=C3001E7C0DA78E4487072B7E050D86C5/Type/@EntryValue">InCSharpFile</s:String>
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Scope/=C3001E7C0DA78E4487072B7E050D86C5/CustomProperties/=minimumLanguageVersion/@EntryIndexedValue">2.0</s:String>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=Entity/@KeyIndexDefined">True</s:Boolean>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=Entity/Order/@EntryValue">0</s:Int64>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=EntityPlural/@KeyIndexDefined">True</s:Boolean>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=EntityPlural/Order/@EntryValue">1</s:Int64>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=DataDomain/@KeyIndexDefined">True</s:Boolean>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=DataDomain/Order/@EntryValue">4</s:Int64>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityLowercase/@KeyIndexDefined">True</s:Boolean>
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityLowercase/Expression/@EntryValue">decapitalize(Entity)</s:String>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityLowercase/InitialRange/@EntryValue">-1</s:Int64>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityLowercase/Order/@EntryValue">2</s:Int64>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityPluralLowercase/@KeyIndexDefined">True</s:Boolean>
	
	
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=entityPluralLowercase/Order/@EntryValue">5</s:Int64>
	<s:Boolean x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=nameSpace/@KeyIndexDefined">True</s:Boolean>
	<s:String x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=nameSpace/Expression/@EntryValue">fileDefaultNamespace()</s:String>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=nameSpace/InitialRange/@EntryValue">-1</s:Int64>
	<s:Int64 x:Key="/Default/PatternsAndTemplates/LiveTemplates/Template/=7670B05F6256254DBDB7764E090E93A1/Field/=nameSpace/Order/@EntryValue">3</s:Int64></wpf:ResourceDictionary>